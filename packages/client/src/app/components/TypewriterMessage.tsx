import { useState, useEffect, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

interface TypewriterMessageProps {
   content: string;
   isNew: boolean;
   onTyping?: () => void; // <--- NEW PROP: Function to call when typing to scroll to new message generation
   onComplete?: () => void; // This new prop will trigger and store the state of message being completely generated by gemini
   // it help to prevent the regeneration of the message if in case user closed the window and click back on the chatbot
}

export const TypewriterMessage = ({
   content,
   isNew,
   onTyping,
   onComplete,
}: TypewriterMessageProps) => {
   const [displayedText, setDisplayedText] = useState('');
   const [isTyping, setIsTyping] = useState(false);
   const indexRef = useRef(0);

   useEffect(() => {
      // 1. If it's an old message, show full content immediately
      if (!isNew) {
         setDisplayedText(content);
         setIsTyping(false);
         return;
      }

      // 2. If it's new, prepare for typing
      setIsTyping(true);
      setDisplayedText('');
      indexRef.current = 0;

      // 3. The Typing Loop
      const intervalId = setInterval(() => {
         // Increment index first
         indexRef.current++;

         // Safely slice the string from 0 to current index
         // This prevents "missing first char" or "undefined" errors
         if (indexRef.current <= content.length) {
            setDisplayedText(content.slice(0, indexRef.current));
            // SCROLL BUG Fix: Wrap in setTimeout to ensure DOM updates first

            // FIX: Another slight change to onTyping to bring some delay ensuring the DOM has grown BEFORE we scroll
            // if (onTyping) {
            //    setTimeout(() => onTyping(), 0); -> requestAnimationFrame(() => onTyping());
            // }

            if (onTyping) {
               requestAnimationFrame(() => onTyping());
            }
         } else {
            // Stop when we reach the end
            clearInterval(intervalId);
            setIsTyping(false);

            //Nofity parent to "Freeze" this message
            if (onComplete) {
               onComplete();
            }
         }
      }, 15); // Speed: 15ms

      // Cleanup interval on unmount
      return () => clearInterval(intervalId);
   }, [content, isNew, onTyping, onComplete]);

   // CURSOR Bug FIX: Append the cursor character directly to the text string
   // We use "▍" (a unicode block) instead of a <span>
   const textWithCursor = isTyping ? displayedText + '▍' : displayedText;

   // 2. NEW: Trigger scroll whenever text changes
   useEffect(() => {
      if (onTyping && isTyping) {
         onTyping(); // Scroll down on every new character
      }
   }, [displayedText, onTyping, isTyping]);

   return (
      <div className="markdown-container text-left">
         <ReactMarkdown
            remarkPlugins={[remarkGfm]}
            components={{
               strong: ({ node, ...props }) => (
                  <span className="font-bold text-white" {...props} />
               ),
               a: ({ node, ...props }) => (
                  <a
                     className="text-[#C9A24D] underline hover:text-[#D1D1D1]"
                     target="_blank"
                     rel="noopener noreferrer"
                     {...props}
                  />
               ),
               ul: ({ node, ...props }) => (
                  <ul className="list-disc pl-4 mb-2 space-y-1" {...props} />
               ),
               ol: ({ node, ...props }) => (
                  <ol className="list-decimal pl-4 mb-2 space-y-1" {...props} />
               ),
               li: ({ node, ...props }) => <li className="pl-1" {...props} />,
               h1: ({ node, ...props }) => (
                  <h1
                     className="text-xl font-bold mb-2 text-[#C9A24D]"
                     {...props}
                  />
               ),
               h2: ({ node, ...props }) => (
                  <h2
                     className="text-lg font-bold mb-2 text-[#C9A24D]"
                     {...props}
                  />
               ),
               p: ({ node, ...props }) => (
                  <p className="mb-2 last:mb-0 leading-relaxed" {...props} />
               ), // Removed 'inline' to fix layout
            }}
         >
            {displayedText}
         </ReactMarkdown>

         {/* Blinking Cursor */}
         {isTyping && (
            <span className="inline-block w-1.5 h-4 ml-0.5 bg-[#C9A24D] animate-pulse align-middle" />
         )}
      </div>
   );
};
